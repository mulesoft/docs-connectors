= Execute Stored Procedures Examples - Mule 4

Anypoint Connector for Database (Database Connector) Stored Procedure operation invokes a stored procedure on the database. When the stored procedure returns one or more ResultSet instances, streaming is applied automatically to avoid preemptive consumption of the results, which can lead to performance and memory issues.

The following examples illustrates callable statements and dates on stored procedures, and how to invoke stored procedures by configuring Input, Output, and In Out parameters.

== Callable Statements in Stored Procedures

Database Connector supports the use of callable statements with the format:

`{ call procedureName(:param1, :param2, ..., :paramN) }`

Where `:paramN` matches the `Nth` parameter in the stored procedure declaration. Make sure that no whitespace is between the name of the stored procedure and the first parentheses.

The following example illustrates an Oracle database that was initialized when creating a table named `SYSTEM.employees` and stored procedure named `createEmployee`:

[source,xml,linenums]
----
    CREATE TABLE SYSTEM.employees(
        employee_id INTEGER GENERATED BY DEFAULT AS IDENTITY,
        employee_name VARCHAR2(100),
        employee_age INTEGER,
        employee_birthday TIMESTAMP,
        PRIMARY KEY(employee_id)
    );


    CREATE PROCEDURE createEmployee(e_name VARCHAR2, e_age NUMBER, e_birth_date DATE) AS
    BEGIN
        INSERT INTO SYSTEM.employees(employee_name, employee_age, employee_birthday) VALUES(e_name, e_age, e_birth_date);
    END;
----

Because Database Connector does not support named parameters in callable statements, attempting to match parameters by name does not work, for example:

`{ call createEmployee(employee_age => :age, e_birth_date => :date, e_name => :name) }`

You must provide the parameters in the appropriate order, for example:

`{ call createEmployee(e_name => :name, employee_age => :age, e_birth_date => :date) }`.


== Use Dates on Stored Procedures

Database Connector does not support the use of engine-specific embedded functions. For example, if you want to change a date to a specific format before calling a procedure in an Oracle database, the following approach does not work:

`{ call createEmployee(e_name => :name, employee_age => :age, e_birth_date => TO_DATE(:date, 'YYYY-MM-DD HH:mm:ss')) }.`

Use DataWeave for all data transformations before the invocation to the callable statement. Using the previous example, perform the following transformation:

. In your Studio flow, select the *Stored procedure* operation.
. In the operation configuration screen, set the *SQL Query Text* field to the query to execute, for example:
+
`{ call createEmployee(:name, :age, :date) }`
+
. Set the *Input parameters* field to the following DataWeave code:

[source,dataweave,linenums]
----
%dw 2.0
  output application/json
  fun format(d: DateTime) = d as String { format: "yyyy-MM-dd HH:mm:ss" }
  ---
  { 'date': format(|2019-10-31T13:00:00.000Z|), 'name': 'rick', 'age': 60 }

[source,xml,linenums]
----

The following screenshot shows the configuration:

.Dates on Stored Procedure configuration
image::database-stored-example-4.png[Dates on Stored Procedure configuration in Studio]

In the XML editor, the `<db:input-parameters>` with the DataWeave transformation looks like this:

[source,xml,linenums]
----
<db:stored-procedure doc:name="Create Employee" config-ref="Database_Config">
    <db:sql>{ call createEmployee(:name, :age, :date) }</db:sql>
		<db:input-parameters>
		 	<![CDATA[#[%dw 2.0
				output application/json
				fun format(d: DateTime) = d as String { format: "yyyy-MM-dd HH:mm:ss" }
				---
				{ 'date': format(|2019-10-31T13:00:00.000Z|), 'name': 'rick', 'age': 60 }
			]]]>
		</db:input-parameters>
	</db:stored-procedure>
----


== Configure the Stored Procedure Operation with the Input Parameters Field

In the Input parameters field, specify values that create a map in which keys are the name of an input parameter to be set on the JDBC prepared statement. Reference each parameter in the SQL text using a colon prefix, for example, `where id = :myParamName`. The map’s values contain the actual assignation for each parameter.

To configure the Stored Procedure operation:

. In your Studio flow, select the *Stored procedure* operation.
. In the operation configuration screen, set the *SQL Query Text* field to the query to execute, for example:
+
`{ call updatePlanetDescription('Venus', :description) }`
+
. Set the *Input parameters* field to `{'description' : payload}`.

The following screenshot shows the configuration:

.Stored procedure with Input parameter configuration
image::database-stored-example-1.png[Stored procedure with Input parameter configuration]

In the XML editor, the `<db:stored-procedure>` and `<db:input-parameters>` configuration looks like this:

[source,xml,linenums]
----
<db:stored-procedure config-ref="dbConfig">
    <db:sql>{ call updatePlanetDescription('Venus', :description) }</db:sql>
    <db:input-parameters>
        #[{'description' : payload}]
    </db:input-parameters>
</db:stored-procedure>
----
== Configure the Stored Procedure Operation with the In Out Parameters Field

In the In Out Parameters field, specify values that create a map in which keys are the name of a parameter to be set on the JDBC prepared statement which is both input and output. Reference each parameter in the SQL text using a colon prefix, for example, `where id = :myParamName`. The map’s values contain the actual assignation for each parameter.

To configure the Stored Procedure operation:

. In your Studio flow, select the *Stored procedure* operation.
. In the operation configuration screen, set the *SQL Query Text* field to the query to execute, for example:
+
`{ call updatePlanetDescription('Venus', :description) }`
+
. Set the *In out parameters* field to `Edit inline`.
. Click the plus sign (*+*) to add a new value.
. In the new window, set the *Key* field to `myInt` and the *Value* field to `3`.

The following screenshot shows the configuration:

.Stored procedure with In Out parameters configuration
image::database-stored-example-2.png[Stored procedure with In Out parameters configuration]

In the XML editor, the `<db:stored-procedure>` and `<db:in-out-parameter>` configuration looks like this:

[source,xml,linenums]
----
<db:stored-procedure config-ref="dbConfig">
  <db:sql>{ call doubleMyInt(:myInt) }</db:sql>
  <db:in-out-parameters>
      <db:in-out-parameter key="myInt" value="3"/>
  </db:in-out-parameters>
</db:stored-procedure>
----

== Configure the Stored Procedure Operation with the Input and Output Parameters Fields

In the Output Parameters field, specify a list of values to be set on the JDBC prepared statement. Reference each parameter in the SQL text using a colon prefix, for example,  `call multiply(:value, :result)`.

To configure the Stored Procedure operation:

. In your Studio flow, select the *Stored procedure* operation.
. In the operation configuration screen, set the *SQL Query Text* field to the query to execute, for example:
+
`{ call multiplyInts(:int1, :int2, :result1, :int3, :result2) }`
+
. Set the *Input parameters* field to:
+
[source,xml,linenums]
----
{
    'int1' : 3,
    'int2' : 4,
    'int3' : 5
}
----
+
[start=4]
. Set the *Output parameters* field to `Edit inline`.
. Click the plus sign (*+*) to add a new value.
. In the new window, set the *Key* field to `result1` and the *Type* field to `INTEGER`.
. Repeat the steps 5 and 6 to add a new value, set the *Key* field to `result2` and the *Type* field to `INTEGER`.
. Repeat again the steps 5 and 6 to add another value and set the *Key* field to `myInt` and the *Type* field to `INTEGER`.

The following screenshot shows the configuration:

.Stored procedure with Input and Output parameters configuration
image::database-stored-example-3.png[Stored procedure with Input and Output parameters configuration]

In the XML editor, the `<db:input-parameters>` and `<db:output-parameters>` configuration looks like this:

[source,xml,linenums]
----
<db:stored-procedure config-ref="dbConfig">
    <db:sql>{ call multiplyInts(:int1, :int2, :result1, :int3, :result2) }</db:sql>
    <db:input-parameters>
        #[{
            'int1' : 3,
            'int2' : 4,
            'int3' : 5
        }]
    </db:input-parameters>
    <db:output-parameters>
        <db:output-parameter key="result1" type="INTEGER"/>
        <db:output-parameter key="result2" type="INTEGER"/>
        <db:output-parameter key="myInt" type="INTEGER"/>
    </db:output-parameters>
</db:stored-procedure>
----


== See Also

xref:database-connector-examples.adoc[Database Connector Examples]
