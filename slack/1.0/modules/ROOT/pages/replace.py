# Python script created by Sejal Parikh, March 2019
#
# Latest change: 16 Dec 2019
#
# Use this script to prep a connector reference to convert the text 
# for our style guidelines and to correct typos generated by the 
# Maven connector reference generator.
#
# To run: $ python sejal_find_replace.py <name_of_file>
#
# This command creates a new file named <name_of_file>_revised 
#
# To create a connector reference, cd to the root folder of a 
# cloned code repo folder and type: mvn clean package -DskipTests
#
# The raw reference asciidoc file appears in the repo's /target/docs folder.
# Then run this script against the raw reference to prep it. You will still
# need to change the file name to <connector>-connector-reference.adoc,
# ensure that the = Title statement is the first line of the file, and that
# the subsequent lines after the title are (without hash-space) are:
# ifndef::env-site,env-github[]
# include::_attributes.adoc[]
# endif::[]

import sys

remove_prefix_list = [
	':toc:',
	':toc-title:',
	':toclevels:',
	':last-update-label!:',
	':docinfo:',
	':source-highlighter:',
	':icons:'
	]

replace_text_dict = {
	' strategy |': ' strategy. |',
	' to storeoperation': ' to store the operation',
	'(in ms)': 'in milliseconds',
	'*Attributes Type*': 'Attributes Type',
	'*x*': 'x',
	'+++#[payload]+++': '`#[payload]`',
	'+++a ': '+++A ',
	'+++maximum ': '+++Maximum ',
	'+++the': '+++The',
	'+++true ': '+++True ',
	'<a href="': '',
	'<a href=': '',
	'html">': 'html[',
	'html>': 'html[',
	'</a>': ']',
	'</code>': '`',
	'</i>': '`',
	'</li>': '',
	'<p>': '',
	'</p>': '',
	'</pre>': '`',
	'</ul>': '',
	'<br>': '',
	'<code>': '`',
	'<i>': '`',
	'<li>': '',
	'<pre> ': '`',
	'<pre>': '`',
	'<ul>': '',
	'+++': '',
	'<<non-repeatable-iterable>>': 'non-repeatable-iterable',
	'<<non-repeatable-stream>>': 'non-repeatable-stream',
	'<<ObjectStore>>': 'Object Store',
	'<<scheduling-strategy>>': 'scheduling-strategy',
	'=== Operation': '== Operation',
	'==== Associated Operations': '== Supported Operations',
	'==== For Configurations.': '=== For Configurations',
	'[cols=".^20%,.^20%,.^35%,.^20%,^.^5%", options="header"]': '[%header,cols="20s,20a,35a,20a,5a"]',
	'[cols=".^20%,.^25%,.^30%,.^15%,.^10%", options="header"]': '[%header,cols="20s,25a,30a,15a,10a"]',
	'[cols=".^50%,.^50%"]': '[%autowidth.spread]',
	'``': '`',
	'A retry strategy in case of connectivity errors+++': 'A retry strategy in case of connectivity errors.+++',
	'Amount of Sessions to cache |': 'Number of sessions to cache. |',
	'attempts |': 'attempts. |',
	'ehaviour': 'ehavior',
	'cknowledgement': 'cknowledgment',
	'comma separated': 'comma-separated',
	'then it will start to buffer the content on disk': 'content on the disk is buffered',
	'Configure if repeatable streams should be used and their behavior': 'Configure to use repeatable streams.',
	'Connector Documentation Reference': 'Connector Reference',
	'correlation ids ': 'correlation IDs ',
	'correlation Ids ': 'correlation IDs ',
	'destionations': 'destinations',
	'error will be raised': 'error is raised',
	'hitelist': 'hite list',
	'running in Cluster ': 'running in a cluster. ',
	'How many reconnection attempts to make': 'How many reconnection attempts to make.',
	'How often (in ms) to reconnect': 'How often in milliseconds to reconnect.',
	'If this property is not set then ': 'If this property is not set, then ',
	'If true;': 'If true,',
	'in order to': 'to',
	'is part of |': 'is part of. |',
	'It must be provided ': 'Provide this ',
	'it sees it fit': 'as appropriate',
	'it will default': 'it defaults',
	'lower will mean': 'lower means',
	'output will be placed': 'output.',
	'proxy will be used': 'proxy is used',
	'redelivered message |': 'redelivered message. |',
	'running in Cluster': 'running in a cluster',
	'runnning': 'running',
	'that can be provided': 'to provide',
	'that will be configured': 'to configure',
	'that will be evaluated': 'to evaluate',
	'that will be used': 'to use',
	'The action name that is going to be called+': 'The action name to call.+',
	'the consumer will attempt': 'the consumer attempts',
	'the consumer will wait': 'the consumer waits',
	'the consumer |': 'the consumer. |',
	'the group |': 'the group. |',
	'the message |': 'the message. |',
	'The name of a variable on which the ': 'The name of a variable to store',
	'the outcome of that expression will be stored': 'store the expression outcome',
	'The reconnection strategy to use |': 'The reconnection strategy to use. |',
	'then it will be expanded according': 'then the buffer expands according',
	'then it will be expanded by according': 'then the buffer expands according',
	'This is the ': 'The ',
	'the amount of instances that is initially be allowed to be kept': 'the number of instances to initially keep',
	'time, in milliseconds, that': 'time in milliseconds that',
	'to be executed': 'to execute',
	'to be used': 'to use',
	'value lower or equal': 'value lower than or equal',
	'was consumed |': 'was consumed. |',
	'was produced |': 'was produced. |',
	'where a reply to a message should be sent': 'where to send a reply to a message.',
	'will actually purge': 'purges',
	'will be buffer size by expanded': 'the buffer size expands',
	'will the buffer size by expanded': 'the buffer size expands',
	'will be flagged': 'is flagged',
	'The runtime': 'Mule',
	'the runtime': 'Mule',
	'when as ': 'as ',
	'running in Cluster ': 'running in a cluster. ',
	'will be in': 'is in',
	'will be sent': 'is sent',
	'will be taken+': 'is taken.+',
	'will depend': 'depends',
	'will expire': 'expires',
	'will fail': 'fails',
	'will redeliver': 'redelivers',
	'will attempt': 'attempts',
	'will continue': 'continues',
	'will wait': 'waits',
	'is going to be': 'is',
	'that will be kept': 'to keep',
	'e.g.': ', for example',
	' id ': ' ID ',
	'{nbsp}': '',
	'| *Type* a| ': '|Type |',
	'| *x*{nbsp}': '|x',
	'|======================': '|==='
	}

input_file = sys.argv[1]
out_file = input_file[:-5] + '_revised' + input_file[-5:]
f_in = open(input_file, 'r')
f_out = open(out_file, 'w')

filedata = f_in.read()

for line in filedata.splitlines():
	remove_prefix_found = False
	for remove_prefix in remove_prefix_list:
		if line.startswith(remove_prefix):
			replace_text_dict[line + '\n'] = ''
			remove_prefix_found = True
			break
	if remove_prefix_found == False:
		break

for k,v in replace_text_dict.items():
	filedata = filedata.replace(k, v)

f_out.write(filedata)

f_in.close()
f_out.close()